// ====================================================================
//  檔案：code.gs (AV放送立願報名行事曆 - 後端 API)
//  版本：5.1 (最終修正版 - 將邏輯移至 doGet)
// ====================================================================

// --- 已填入您提供的 CSV 網址 ---
const EVENTS_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRT5YNZcSXbE6ULGft15cba4Mx8kK1Eb7bLftucmkmUGmTxkrA8vw5uerAP2dYqptBHnbmq_3QNOOJx/pub?gid=795926947&single=true&output=csv";
const SIGNUPS_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRT5YNZcSXbE6ULGft15cba4Mx8kK1Eb7bLftucmkmUGmTxkrA8vw5uerAP2dYqptBHnbmq_3QNOOJx/pub?gid=767193030&single=true&output=csv";
// ---------------------------------------------------

// --- 全域設定 ---
const SHEET_ID = '1gBIlhEKPQHBvslY29veTdMEJeg2eVcaJx_7A-8cTWIM';
const EVENTS_SHEET_NAME = 'Events';
const SIGNUPS_SHEET_NAME = 'Signups';

// -------------------- API 核心路由函式 (已修正) --------------------

function doGet(e) {
  // 【修正】所有 API 邏輯現在都在這裡處理，以回應前端的 GET 請求
  let responsePayload;
  try {
    // 直接存取 GET 請求的參數
    if (!e || !e.parameter || !e.parameter.payload || !e.parameter.callback) {
      // 如果是直接在瀏覽器打開，沒有帶參數，就顯示部署成功訊息
      return HtmlService.createHtmlOutput("API 後端已部署。");
    }
    
    const request = JSON.parse(e.parameter.payload);
    const functionName = request.functionName;
    const params = request.params || {};
    let result;

    // API 路由器
    switch (functionName) {
      case 'getEventsAndSignups': result = getEventsAndSignups(); break;
      case 'getAllSignups': result = getAllSignups(params.startDateStr, params.endDateStr); break;
      case 'getStatsData': result = getStatsData(params.startDateStr, params.endDateStr); break;
      case 'getMySignups': result = getMySignups(params.userName, params.startDateStr, params.endDateStr); break;
      case 'getUniqueSignupNames': result = getUniqueSignupNames(params.startDateStr, params.endDateStr); break;
      case 'addSignup': result = addSignup(params.eventId, params.userName, params.position); break;
      case 'addBackupSignup': result = addBackupSignup(params.eventId, params.userName, params.position); break;
      case 'removeSignup': result = removeSignup(params.eventId, params.userName); break;
      case 'createTempSheetAndExport': result = createTempSheetAndExport(params.startDateStr, params.endDateStr); break;
      case 'scheduleDeletion': scheduleDeletion(params.sheetName); result = { status: 'scheduled' }; break;
      case 'exportAndEmailReport': result = exportAndEmailReport(params.startDateStr, params.endDateStr, params.recipientEmail); break;
      case 'deleteAllTempSheets': result = deleteAllTempSheets(); break;
      default: throw new Error(`未知的函式名稱: ${functionName}`);
    }

    responsePayload = { status: 'success', data: result };

  } catch (err) {
    console.error(`doGet 執行失敗: ${err.message}\n${err.stack}`);
    responsePayload = { status: 'error', message: err.message };
  }

  // 使用 JSONP 格式回傳資料
  const callbackFunctionName = e.parameter.callback;
  const jsonpResponse = `${callbackFunctionName}(${JSON.stringify(responsePayload)})`;
  
  return ContentService.createTextOutput(jsonpResponse).setMimeType(ContentService.MimeType.JAVASCRIPT);
}

// doPost 現在可以留空或指向 doGet
function doPost(e) {
  return doGet(e);
}


// -------------------- 核心資料獲取函式 (CSV 讀取最終版) --------------------
function getMasterData() {
  if (EVENTS_CSV_URL.includes("在此貼上") || SIGNUPS_CSV_URL.includes("在此貼上")) {
    throw new Error("後端程式碼尚未設定 Events 和 Signups 的 CSV 網址。");
  }

  try {
    const requests = [
      { url: EVENTS_CSV_URL, muteHttpExceptions: true },
      { url: SIGNUPS_CSV_URL, muteHttpExceptions: true }
    ];
    const responses = UrlFetchApp.fetchAll(requests);
    
    const eventsResponse = responses[0];
    const signupsResponse = responses[1];

    if (eventsResponse.getResponseCode() !== 200) throw new Error(`無法獲取 Events CSV 資料。錯誤碼: ${eventsResponse.getResponseCode()}`);
    if (signupsResponse.getResponseCode() !== 200) throw new Error(`無法獲取 Signups CSV 資料。錯誤碼: ${signupsResponse.getResponseCode()}`);

    const eventsData = Utilities.parseCsv(eventsResponse.getContentText());
    const signupsData = Utilities.parseCsv(signupsResponse.getContentText());

    eventsData.shift();
    signupsData.shift();

    const scriptTimeZone = Session.getScriptTimeZone();
    const eventsMap = new Map();
    eventsData.forEach(row => {
      const eventId = row[0];
      if (eventId) {
        eventsMap.set(eventId, {
          title: row[1] || '未知事件',
          dateString: row[2] ? Utilities.formatDate(new Date(row[2]), scriptTimeZone, 'yyyy/MM/dd') : '',
          dateObj: new Date(row[2])
        });
      }
    });

    return { eventsData, signupsData, eventsMap };
  } catch (err) {
    console.error(`getMasterData (CSV) 失敗: ${err.message}`, err.stack);
    throw new Error(`從 CSV 網址讀取資料時發生錯誤: ${err.message}`);
  }
}

// -------------------- 其他所有功能函式 (無需修改) --------------------
function getEventsAndSignups() {
  try {
    const { eventsData, signupsData } = getMasterData();
    const scriptTimeZone = Session.getScriptTimeZone();

    const signupsByEventId = new Map();
    signupsData.forEach(row => {
      const eventId = row[1];
      if (!eventId) return;
      if (!signupsByEventId.has(eventId)) {
        signupsByEventId.set(eventId, []);
      }
      signupsByEventId.get(eventId).push({ user: row[2], position: row[4] });
    });

    const formatDate = (date) => Utilities.formatDate(new Date(date), scriptTimeZone, "yyyy-MM-dd");
    const formatTime = (time) => Utilities.formatDate(new Date(time), scriptTimeZone, "HH:mm");

    return eventsData.map(row => {
      const eventId = row[0];
      if (!eventId) return null;
      
      const title = row[1], date = row[2], startTime = row[3], endTime = row[4];
      const maxAttendees = parseInt(row[5], 10) || 999;
      const positions = (row[6] || '').split(',').map(p => p.trim()).filter(p => p);
      const description = row[7];
      
      const signups = signupsByEventId.get(eventId) || [];
      const signupCount = signups.length;
      const isFull = signupCount >= maxAttendees;
      
      let eventColor, textColor;
      if (isFull) { eventColor = '#6c757d'; textColor = 'white'; } 
      else if (signupCount > 0) { eventColor = '#0d6efd'; textColor = 'white'; } 
      else { eventColor = '#e9ecef'; textColor = '#212529'; }
      
      return {
        id: eventId,
        title: title,
        start: `${formatDate(date)}T${formatTime(startTime)}`,
        end: `${formatDate(date)}T${formatTime(endTime)}`,
        backgroundColor: eventColor,
        borderColor: eventColor,
        textColor: textColor,
        extendedProps: { full_title: title, description, maxAttendees, signups, positions, startTime: formatTime(startTime) }
      };
    }).filter(e => e);
  } catch(err) { console.error("getEventsAndSignups 失敗:", err.message, err.stack); throw err; }
}

function getAllSignups(startDateStr, endDateStr) {
  try {
    const { signupsData, eventsMap } = getMasterData();
    const scriptTimeZone = Session.getScriptTimeZone();

    let filteredSignups = signupsData;
    if (startDateStr && endDateStr) {
      const start = new Date(startDateStr);
      const end = new Date(endDateStr);
      end.setHours(23, 59, 59, 999);
      
      filteredSignups = signupsData.filter(row => {
        const eventDetail = eventsMap.get(row[1]);
        return eventDetail && eventDetail.dateObj && eventDetail.dateObj >= start && eventDetail.dateObj <= end;
      });
    }
    
    return filteredSignups.map(row => {
      const eventId = row[1];
      const eventDetail = eventsMap.get(eventId) || { title: '未知事件', dateString: '日期無效'};
      const timestamp = new Date(row[3]);
      return {
        signupId: row[0],
        eventId: eventId,
        eventTitle: eventDetail.title,
        eventDate: eventDetail.dateString,
        user: row[2],
        timestamp: !isNaN(timestamp) ? Utilities.formatDate(timestamp, scriptTimeZone, 'yyyy/MM/dd HH:mm') : '時間無效',
        position: row[4]
      };
    });
  } catch(err) { console.error("getAllSignups 失敗:", err.message, err.stack); throw err; }
}

function addSignup(eventId, userName, position) {
  if (!eventId || !userName || !position) { return { status: 'error', message: '缺少必要資訊 (事件ID, 姓名或崗位)。' }; }
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
    const signupsSheet = ss.getSheetByName(SIGNUPS_SHEET_NAME);
    const eventData = eventsSheet.getDataRange().getValues().find(row => row[0] === eventId);
    if (!eventData) return { status: 'error', message: '找不到此活動。' };
    const eventDatePart = new Date(eventData[2]);
    const eventTimePart = new Date(eventData[4]);
    const eventEndDateTime = new Date( eventDatePart.getFullYear(), eventDatePart.getMonth(), eventDatePart.getDate(), eventTimePart.getHours(), eventTimePart.getMinutes(), eventTimePart.getSeconds() );
    if (new Date() > eventEndDateTime) { return { status: 'error', message: '此活動已結束，無法再進行報名。' }; }
    const currentSignups = signupsSheet.getDataRange().getValues().filter(row => row[1] === eventId);
    if (currentSignups.some(row => row[2] === userName)) { return { status: 'error', message: '您已經報名過此活動了。' }; }
    const existingPositionHolder = currentSignups.find(row => row[4] === position);
    if (existingPositionHolder) { return { status: 'confirm_backup', message: `此崗位目前由 [${existingPositionHolder[2]}] 報名，您要改為報名備援嗎？`, }; }
    const maxAttendees = eventData[5];
    if (currentSignups.length >= maxAttendees) { return { status: 'error', message: '很抱歉，活動總人數已額滿。' }; }
    const newSignupId = 'su' + new Date().getTime();
    signupsSheet.appendRow([newSignupId, eventId, userName, new Date(), position]);
    return { status: 'success', message: '報名成功！' };
  } catch(err) { console.error("addSignup 失敗:", err.message, err.stack); throw new Error('報名時發生未預期的錯誤。');
  } finally { lock.releaseLock(); }
}

function removeSignup(eventId, userName) {
  if (!eventId || !userName) return { status: 'error', message: '缺少事件ID或姓名。' };
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const ss = SpreadsheetApp.openById(SHEET_ID);
    const signupsSheet = ss.getSheetByName(SIGNUPS_SHEET_NAME);
    const eventsSheet = ss.getSheetByName(EVENTS_SHEET_NAME);
    const eventData = eventsSheet.getDataRange().getValues().find(row => row[0] === eventId);
    if (!eventData) return { status: 'error', message: '找不到對應的活動資訊。' };
    const eventDatePart = new Date(eventData[2]);
    const eventTimePart = new Date(eventData[4]);
    const eventEndDateTime = new Date( eventDatePart.getFullYear(), eventDatePart.getMonth(), eventDatePart.getDate(), eventTimePart.getHours(), eventTimePart.getMinutes(), eventTimePart.getSeconds() );
    if (new Date() > eventEndDateTime) { return { status: 'error', message: '此活動已結束，無法取消報名。' }; }
    const signupsData = signupsSheet.getDataRange().getValues();
    let found = false;
    for (let i = signupsData.length - 1; i >= 1; i--) { if (signupsData[i][1] === eventId && signupsData[i][2] === userName) { signupsSheet.deleteRow(i + 1); found = true; break; } }
    if (found) { return { status: 'success', message: '已為您取消報名。' }; }
    return { status: 'error', message: '找不到您的報名紀錄。' };
  } catch(err) { console.error("removeSignup 失敗:", err.message, err.stack); throw new Error('取消報名時發生未預期的錯誤。');
  } finally { lock.releaseLock(); }
}

function addBackupSignup(eventId, userName, position) { if (!eventId || !userName || !position) { return { status: 'error', message: '缺少必要資訊。' }; } const lock = LockService.getScriptLock(); lock.waitLock(15000); try { const ss = SpreadsheetApp.openById(SHEET_ID); const signupsSheet = ss.getSheetByName(SIGNUPS_SHEET_NAME); const finalPosition = `${position} (備援)`; const newSignupId = 'su' + new Date().getTime(); signupsSheet.appendRow([newSignupId, eventId, userName, new Date(), finalPosition]); return { status: 'success', message: '已成功為您報名備援！' }; } catch (err) { console.error("addBackupSignup 失敗:", err.message, err.stack); throw new Error('備援報名時發生錯誤。'); } finally { lock.releaseLock(); } }
function getMySignups(userName, startDateStr, endDateStr) { if (!userName) return []; try { return getAllSignups(startDateStr, endDateStr).filter(signup => signup.user === userName); } catch (err) { console.error("getMySignups 失敗:", err.message, err.stack); throw err; } }
function getStatsData(startDateStr, endDateStr) { try { const { eventsMap } = getMasterData(); const allSignups = getAllSignups(startDateStr, endDateStr); if (!allSignups || allSignups.length === 0) { return { labels: [], data: [], fullDetails: [] }; } const statsByEventId = {}; allSignups.forEach(signup => { const eventId = signup.eventId; if (!statsByEventId[eventId]) { const eventInfo = eventsMap.get(eventId) || { title: signup.eventTitle, date: signup.eventDate }; statsByEventId[eventId] = { count: 0, signups: [], eventInfo: { title: eventInfo.title, date: eventInfo.dateString }, label: `${eventInfo.title} (${eventInfo.dateString})` }; } statsByEventId[eventId].count++; statsByEventId[eventId].signups.push({ user: signup.user, position: signup.position }); }); const processedData = Object.values(statsByEventId); processedData.sort((a, b) => { const dateA = new Date(a.eventInfo.date).getTime(); const dateB = new Date(b.eventInfo.date).getTime(); return dateA - dateB; }); const labels = processedData.map(item => item.label); const data = processedData.map(item => item.count); const fullDetails = processedData.map(item => { item.signups.sort((a,b) => a.position.localeCompare(b.position)); return { eventInfo: item.eventInfo, signups: item.signups }; }); return { labels, data, fullDetails }; } catch (err) { console.error("getStatsData 失敗:", err.message, err.stack); throw err; } }
function getUniqueSignupNames(startDateStr, endDateStr) { try { const signups = getAllSignups(startDateStr, endDateStr); if (!signups || signups.length === 0) { return []; } const nameSet = new Set(signups.map(s => s.user)); return Array.from(nameSet).sort((a, b) => a.localeCompare(b, 'zh-Hant')); } catch (err) { console.error("getUniqueSignupNames 失敗:", err.message, err.stack); throw err; } }
function createTempSheetAndExport(startDateStr, endDateStr) { const ss = SpreadsheetApp.openById(SHEET_ID); const spreadsheetId = ss.getId(); let tempSheet; try { const file = DriveApp.getFileById(spreadsheetId); file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); const tempSheetName = "匯出報表_" + new Date().getTime(); tempSheet = ss.insertSheet(tempSheetName); const data = getAllSignups(startDateStr, endDateStr); if (!data || data.length === 0) { ss.deleteSheet(tempSheet); return { status: 'nodata', message: '在選定的日期範圍內沒有任何報名記錄。' }; } data.sort((a, b) => { const dateA = new Date(a.eventDate).getTime() || 0; const dateB = new Date(b.eventDate).getTime() || 0; if (dateA !== dateB) { return dateA - dateB; } const timeA = new Date(a.timestamp).getTime() || 0; const timeB = new Date(b.timestamp).getTime() || 0; return timeA - timeB; }); const dateRangeText = `(${startDateStr || '所有'} - ${endDateStr || '所有'})`; const title = `AV放送立願報名記錄 ${dateRangeText}`; tempSheet.getRange("A1:E1").merge().setValue(title).setFontWeight("bold").setFontSize(15).setHorizontalAlignment('center'); const headers = ["活動日期", "活動", "崗位", "報名者", "報名時間"]; const fields = ["eventDate", "eventTitle", "position", "user", "timestamp"]; const headerRange = tempSheet.getRange(2, 1, 1, headers.length); headerRange.setValues([headers]).setFontWeight("bold").setBackground("#d9ead3").setFontSize(15).setHorizontalAlignment('center'); const outputData = data.map(row => fields.map(field => row[field] || "")); if (outputData.length > 0) { const dataRange = tempSheet.getRange(3, 1, outputData.length, headers.length); dataRange.setValues(outputData).setFontSize(15).setHorizontalAlignment('left'); } tempSheet.setColumnWidth(1, 160); tempSheet.setColumnWidth(2, 420); tempSheet.setColumnWidth(3, 220); tempSheet.setColumnWidth(4, 160); tempSheet.setColumnWidth(5, 280); SpreadsheetApp.flush(); Utilities.sleep(5000); const gid = tempSheet.getSheetId(); const exportUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=xlsx&gid=${gid}`; return { status: 'success', url: exportUrl, sheetName: tempSheet.getName() }; } catch (e) { console.error("createTempSheetAndExport 失敗: " + e.toString()); if (tempSheet && ss.getSheetByName(tempSheet.getName())) { ss.deleteSheet(tempSheet); } throw new Error('匯出時發生錯誤: ' + e.toString()); } }
function exportAndEmailReport(startDateStr, endDateStr, recipientEmail) { const ss = SpreadsheetApp.openById(SHEET_ID); const spreadsheetId = ss.getId(); let tempSheet; try { if (!recipientEmail) { return { status: 'error', message: '未提供收件人Email地址。' }; } const file = DriveApp.getFileById(spreadsheetId); file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); tempSheet = ss.insertSheet("郵寄報表_" + new Date().getTime()); const data = getAllSignups(startDateStr, endDateStr); if (!data || data.length === 0) { ss.deleteSheet(tempSheet); return { status: 'nodata', message: '在選定的日期範圍内沒有任何報名記錄。' }; } data.sort((a, b) => { const dateA = new Date(a.eventDate).getTime() || 0; const dateB = new Date(b.eventDate).getTime() || 0; if (dateA !== dateB) { return dateA - dateB; } const timeA = new Date(a.timestamp).getTime() || 0; const timeB = new Date(b.timestamp).getTime() || 0; return timeA - timeB; }); const dateRangeText = `(${startDateStr || '所有'} - ${endDateStr || '所有'})`; const title = `AV放送立願報名記錄 ${dateRangeText}`; tempSheet.getRange("A1:E1").merge().setValue(title).setFontWeight("bold").setFontSize(15).setHorizontalAlignment('center'); const headers = ["活動日期", "活動", "崗位", "報名者", "報名時間"]; const fields = ["eventDate", "eventTitle", "position", "user", "timestamp"]; const headerRange = tempSheet.getRange(2, 1, 1, headers.length); headerRange.setValues([headers]).setFontWeight("bold").setBackground("#d9ead3").setFontSize(15).setHorizontalAlignment('center'); const outputData = data.map(row => fields.map(field => row[field] || "")); if (outputData.length > 0) { const dataRange = tempSheet.getRange(3, 1, outputData.length, headers.length); dataRange.setValues(outputData).setFontSize(15).setHorizontalAlignment('left'); } tempSheet.setColumnWidth(1, 160); tempSheet.setColumnWidth(2, 420); tempSheet.setColumnWidth(3, 220); tempSheet.setColumnWidth(4, 160); tempSheet.setColumnWidth(5, 280); SpreadsheetApp.flush(); const gid = tempSheet.getSheetId(); const exportUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=xlsx&gid=${gid}`; const token = ScriptApp.getOAuthToken(); const response = UrlFetchApp.fetch(exportUrl, { headers: { 'Authorization': 'Bearer ' + token } }); const blob = response.getBlob().setName(`AV立願報名記錄_${new Date().toISOString().slice(0,10)}.xlsx`); MailApp.sendEmail({ to: recipientEmail, subject: `AV放送立願報名記錄報表 ${dateRangeText}`, htmlBody: `您好：<br><br>附件是您所申請的 AV放送立願報名記錄報表，請查收。<br><br>日期範圍：${dateRangeText}<br><br>此為系統自動發送郵件，請勿直接回覆。`, attachments: [blob] }); ss.deleteSheet(tempSheet); return { status: 'success', message: `報表已成功寄送至 ${recipientEmail}` }; } catch (e) { console.error("exportAndEmailReport 失敗: " + e.toString()); if (tempSheet && ss.getSheetByName(tempSheet.getName())) { ss.deleteSheet(tempSheet); } throw new Error('郵件寄送時發生錯誤: ' + e.toString()); } }
function scheduleDeletion(sheetName) { if (!sheetName) return; try { const trigger = ScriptApp.newTrigger('triggeredDeleteHandler').timeBased().after(24 * 60 * 60 * 1000).create(); PropertiesService.getScriptProperties().setProperty(trigger.getUniqueId(), sheetName); console.log(`已成功排程在 24 小時後刪除工作表 '${sheetName}'。觸發器ID: ${trigger.getUniqueId()}`); } catch (e) { console.error(`排程刪除工作表 '${sheetName}' 時失敗: ${e.toString()}`); } }
function triggeredDeleteHandler(e) { const triggerId = e.triggerUid; const scriptProperties = PropertiesService.getScriptProperties(); const sheetName = scriptProperties.getProperty(triggerId); if (sheetName) { console.log(`觸發器 ${triggerId} 已啟動，準備刪除工作表: ${sheetName}`); deleteSheetByName(sheetName); scriptProperties.deleteProperty(triggerId); } else { console.log(`觸發器 ${triggerId} 已啟動，但找不到對應的工作表名稱屬性。`); } const allTriggers = ScriptApp.getProjectTriggers(); for (let i = 0; i < allTriggers.length; i++) { if (allTriggers[i].getUniqueId() === triggerId) { ScriptApp.deleteTrigger(allTriggers[i]); console.log(`已刪除一次性觸發器: ${triggerId}`); break; } } }
function deleteAllTempSheets() { const lock = LockService.getScriptLock(); lock.waitLock(15000); try { const ss = SpreadsheetApp.openById(SHEET_ID); const allSheets = ss.getSheets(); const scriptProperties = PropertiesService.getScriptProperties(); const allTriggers = ScriptApp.getProjectTriggers(); let deletedSheetsCount = 0; allSheets.forEach(sheet => { const sheetName = sheet.getName(); if (sheetName.startsWith("匯出報表_") || sheetName.startsWith("郵寄報表_")) { ss.deleteSheet(sheet); deletedSheetsCount++; console.log(`已手動刪除工作表: ${sheetName}`); } }); allTriggers.forEach(trigger => { if (trigger.getHandlerFunction() === 'triggeredDeleteHandler') { const triggerId = trigger.getUniqueId(); scriptProperties.deleteProperty(triggerId); ScriptApp.deleteTrigger(trigger); console.log(`已刪除觸發器 ID: ${triggerId}`); } }); if (deletedSheetsCount > 0) { return { status: 'success', message: `已成功清除 ${deletedSheetsCount} 個報表連結及其排程。` }; } else { return { status: 'nodata', message: '目前沒有任何可清除的報表連結。' }; } } catch (e) { console.error("deleteAllTempSheets 失敗: " + e.toString()); throw new Error('清除過程中發生錯誤: ' + e.toString()); } finally { lock.releaseLock(); } }
function deleteSheetByName(sheetName) { if (!sheetName) return; try { const ss = SpreadsheetApp.openById(SHEET_ID); const sheet = ss.getSheetByName(sheetName); if (sheet) { ss.deleteSheet(sheet); console.log(`已成功刪除工作表：'${sheetName}'`); } else { console.log(`嘗試刪除時，找不到工作表：'${sheetName}'`); } } catch (e) { console.error("deleteSheetByName 失敗: " + e.toString()); } }